Technical Design Specification: Intelli-Hire AI Recruitment Platform
1.0 Introduction: Vision and Strategic Goals
1.1 Product Vision & Core Principles
The Intelli-Hire platform is engineered to address a fundamental limitation in modern recruitment: the over-reliance on simple keyword matching. This technical specification outlines an AI-native architecture designed to move beyond superficial analysis, providing recruiters with deep semantic understanding of candidate profiles and verifiable, evidence-based insights. By integrating advanced AI directly into the user's workflow, we aim to transform high-volume candidate screening from a reactive, manual process into a proactive, intelligent one.
The core product vision is to deliver a best-in-class B2B SaaS application that streamlines the candidate screening process for recruiters and hiring managers. The platform will serve as an intelligent co-pilot, surfacing the most promising candidates, verifying claims, and reducing the cognitive load associated with evaluating hundreds of resumes.
This vision is guided by four foundational principles that inform every aspect of the platform's design and architecture:
Privacy-First by Default: The system architecture is built on a "Default to Local" thesis. To protect sensitive candidate information, AI models for core tasks run directly on the user's device. This ensures that resumes and job specifications are processed locally and never leave the user's machine unless explicitly required for advanced, cloud-based analysis, thereby building fundamental user trust.
Aesthetic-Usability Balance: Our design philosophy is rooted in the "Aesthetic-Usability Effect," a principle which states that users perceive aesthetically pleasing designs as more usable. A polished, visually appealing interface signals competence and credibility, building user confidence and enhancing the perceived functionality of the platform.
Verifiable Intelligence: Every insight generated by the Intelli-Hire AI must be transparent and traceable. All analytical claims, from skill assessments to experience summaries, will be directly linked to their source within candidate documents or cross-referenced against external public data points, ensuring that recruiters can trust and verify the AI's conclusions.
Frictionless Experience: The platform is meticulously designed to reduce cognitive load and simplify complex recruitment workflows. Through the implementation of intuitive UI patterns, seamless onboarding, and proactive assistance, we aim to create an experience that feels effortless and empowering for the user.
This document will now provide a detailed breakdown of the user experience design that brings these principles to life.
1.2 Target User Personas
To ensure the Intelli-Hire platform is both productive and relevant, the system is designed to serve the distinct needs of three key user personas. Understanding their unique goals and system interactions is critical to building a successful and targeted B2B SaaS product.
Persona
Primary Goal
Key System Interactions
Administrator
Manages the company's organizational structure, billing information, and user access privileges.
Interacts with company settings, user management panels, subscription and billing interfaces, and security configurations.
Recruiter
Manages high-volume ingestion of candidate resumes, executes initial filtering, and tracks the overall recruitment pipeline.
Utilizes bulk upload features, interacts with search and filtering tools, and manages candidate status via the Kanban workflow board.
Hiring Manager
Performs in-depth reviews of shortlisted candidates, evaluates AI-generated analysis, and verifies candidate claims.
Focuses on individual candidate profiles, interacts with AI summary and explainability features, and reviews external verification results.

The specific needs of these personas directly inform the UI/UX design choices, ensuring that each role is equipped with the tools necessary for maximum efficiency.
2.0 User Experience (UX) and Interface (UI) Design
2.1 Foundational UX/UI Principles
In the competitive SaaS market, a superior user experience is not a luxury but a strategic necessity for reducing churn and increasing adoption. The Intelli-Hire platform's design is therefore grounded in established UX/UI principles to ensure clarity, consistency, and accessibility. By adhering to these standards, we create an intuitive and trustworthy environment that allows users to derive value from the product quickly and effectively.
The following principles form the cornerstone of our UI/UX design strategy:
Simplicity and Minimalism: We are committed to clean, uncluttered layouts that make strategic use of whitespace. This approach enhances focus and readability by eliminating unnecessary visual elements, excessive colors, or distracting animations, guiding the user's attention to the task at hand.
Visual Hierarchy: The interface will employ variations in size, color, contrast, and placement to create a clear visual hierarchy. This technique naturally guides the user's eye to primary elements, such as key data points and critical calls-to-action (CTAs), making the application easier to navigate and understand.
Consistency: A uniform design language will be applied throughout the application. Consistent patterns for colors, typography, button styles, and navigation reduce the user's cognitive load. This predictability builds user confidence and allows them to master the interface more quickly.
Built-in Accessibility: The platform will be designed to meet Web Content Accessibility Guidelines (WCAG) standards from the ground up. This includes ensuring a minimum color contrast ratio of 4.5:1 for small text, providing alternative text for all images, and enabling full keyboard navigation to make the tool usable for everyone.
Responsive Design: Adopting a mobile-first approach, the interface will be built on a fluid grid system. This ensures that the platform adapts seamlessly across all devices, from large desktop monitors to tablets and smartphones, providing a consistent and functional experience regardless of screen size.
These principles provide the framework for the specific user journeys and interface patterns detailed in the following sections.
2.2 Key User Journeys and UI Patterns
The following sections detail the critical user journeys within the Intelli-Hire platform. We will implement specific, proven UI patterns to ensure these journeys are seamless, efficient, and intuitive for our target personas.
User Onboarding
The primary goal of onboarding is to provide a frictionless, role-based introduction to the platform that guides users to their "Aha!" moment as quickly as possible. The process will avoid overwhelming new users by gradually revealing complexity.
Social Logins: To simplify and accelerate the sign-up process, users will have the option to register using existing social accounts.
Short Registration Forms: Initial registration will only request essential information, minimizing friction at the first point of contact.
Inline Validation: Forms will provide real-time feedback (e.g., "Password must be 8+ characters") to reduce errors and prevent user frustration.
Progressive Disclosure: Inspired by platforms like HubSpot, features will be introduced gradually. Interactive walkthroughs, checklists, and tooltips will guide users through the interface, ensuring they learn by doing without feeling overwhelmed. A new Recruiter will first be guided through the resume upload and Kanban board, while a new Hiring Manager's onboarding will focus on the candidate deep-dive and AI explainability features.
Main Dashboard & Navigation
The dashboard serves as a personalized, data-driven command center, providing at-a-glance insights relevant to each user's role. Navigation is designed for clarity and efficiency.
Global Navigation: A persistent top navigation bar provides clear, consistent access to all major tools and features of the application.
Dynamic Sorting & Filtering: A dedicated vertical navigation panel, similar to that used by BuzzSumo, will allow users to dynamically sort and filter candidate lists and data views with precision.
Data Visualization: Drawing inspiration from platforms like Ahrefs and SEMrush, the dashboard will use charts and graphs to make key metrics and analytics easily digestible, allowing users to quickly assess pipeline health and recruitment performance.
Candidate Workflow
This is the core operational view where Recruiters and Hiring Managers will spend most of their time. The design prioritizes clear state management and informative feedback.
Kanban-Style State Machine: A drag-and-drop Kanban board will be used to track candidate progress through distinct stages (e.g., Open -> Pending -> Closed), providing a clear and intuitive visual representation of the recruitment pipeline.
Microinteractions: The interface will incorporate subtle animations and visual cues to provide clear feedback. This includes hover effects on interactive elements, smooth transitions when dragging a candidate between stages, and loading spinners for background processes. For example, when a Recruiter drags a candidate card from 'Pending' to 'Closed,' a subtle 'archive' icon animation will confirm the action, and the system will trigger a background process to remove the candidate's data after the retention period, indicated by a temporary loading spinner on the card.
These user experiences are powered by a sophisticated AI architecture, which is detailed in the next section.
3.0 AI Integration Strategy & Design Patterns
3.1 The Hybrid Architecture: Local-First Intelligence
Our strategic decision to adopt a hybrid AI architecture is a core competitive differentiator. Instead of relying exclusively on costly and potentially insecure cloud-based models, Intelli-Hire is built on a "Default to Local" principle, prioritizing user privacy and performance without sacrificing intelligence.
For the majority of user interactions, such as initial resume parsing and summarization, the platform will utilize on-device AI models. These models run directly in the user's browser, powered by modern web technologies like WebGPU and Transformers.js. This local-first approach ensures that sensitive candidate data is processed on the client's machine and does not need to be transmitted to the cloud.
This strategy delivers significant user and business benefits:
Enhanced Privacy & Trust: By processing data on the client's device, we eliminate the inherent privacy risks of cloud transfer. This builds foundational user trust, a critical asset when handling sensitive personal information.
Reduced Latency: On-device processing provides instant responses without the lag associated with network round-trips, creating a fluid and highly responsive user experience.
Offline Capability: Core features can function reliably even without a stable internet connection, increasing the platform's utility and dependability.
Cost Efficiency: This architecture dramatically lowers operational costs by minimizing the need for server-side compute resources and API token fees. This makes our freemium model sustainable and allows us to offer powerful core features for free.
For computationally intensive "heavy" tasks that exceed the capabilities of local models—such as multi-document analysis or complex external data verification—the platform will intelligently route requests to powerful cloud-based models like Vertex AI's Gemini 1.5 Pro. This policy-based routing system ensures that we use the right tool for the job, balancing cost, performance, and privacy.
The following section details the specific design patterns that will make this hybrid intelligence intuitive and controllable for the end-user.
3.2 Core AI Design Patterns
To ensure our AI is a transparent, controllable, and useful partner rather than an opaque "black box," we will implement proven AI design patterns. These patterns are crucial for building user trust, enhancing usability, and delivering a resilient, human-centered AI experience.
Enhancing User Control & Customization
Style Lenses (Temperature Knobs): The interface will include controls, such as sliders or dropdowns, that allow users to adjust the "creativity" or "formality" of AI-generated content like candidate summaries. For example, a Hiring Manager can use a 'Formality' slider to adjust a candidate summary from a concise, bulleted list for internal review to a formal paragraph suitable for sharing with executives.
Prompt Presets & Templates: A library of pre-built prompts will be available for common recruitment tasks (e.g., "Summarize this candidate's suitability for a senior engineering role," "Generate interview questions based on this resume"). This streamlines workflows and helps users get high-quality results quickly.
Scoping: Users will be able to constrain the AI's analysis to specific parameters. For instance, a hiring manager could instruct the AI to focus its analysis only on a candidate's technical experience from the last five years, ensuring the output is highly relevant.
Building Trust Through Transparency
Explainability Layers: To make AI decisions transparent, users can "drill down" to understand how a conclusion was reached. An insight will start as a simple summary, but the user can expand it to see the specific text in the source PDF that the AI used to generate its claim, fulfilling our "Internal Verification" principle.
AI Daemons: The system will utilize background AI agents, or "daemons," to offer different perspectives on a candidate. For example, a "Compensation Daemon" could flag a candidate's stated salary expectation as being 20% above the market rate for the specified role, based on integrated market data.
Stream of Thought: For complex tasks like external verification, the UI will reveal the AI's reasoning process in real-time. The user will be able to see the steps the AI is taking (e.g., "Searching LinkedIn for profile," "Analyzing GitHub repositories for project activity") to build confidence in the final result.
Ensuring a Resilient & Proactive Experience
Error Recovery: The platform will provide simple mechanisms for users to correct AI mistakes. This includes an "undo" button for an incorrect data extraction or the ability to manually edit an AI-assigned skill tag. If the AI incorrectly parses 'Java' as 'JavaScript,' the Recruiter can click an 'Edit Skill' button directly on the candidate profile to correct the tag, providing feedback that can be used for model refinement.
Predictive Assistance: The system will anticipate user needs and offer proactive support. For example, after analyzing a candidate's profile against a job description, the AI can proactively suggest a list of tailored interview questions designed to probe specific skills or experience areas.
These AI design patterns are supported by a scalable and secure technical architecture, detailed below.
4.0 System Architecture and Technology Stack
4.1 Architectural Approach: Serverless & Event-Driven
The Intelli-Hire platform is built on a Serverless Microservices architecture hosted on Google Cloud. This approach was chosen specifically for its benefits to a startup environment: it optimizes costs by scaling to zero during periods of inactivity, significantly reduces infrastructure maintenance overhead, and enables rapid development and iteration cycles.
The core architectural pattern is Event-Driven, which decouples system processes. This ensures that the user interface remains fast and responsive, even while intensive AI processing tasks are running on the backend. When a user uploads a resume, the action triggers a series of asynchronous events rather than blocking the user's workflow.
Core Technology Stack
Component
Technology Choice
Rationale
Frontend Framework
React (TypeScript) with Vite
Provides a robust ecosystem for building complex UIs and leverages strong typing with TypeScript to ensure code safety and maintainability.
Identity & Auth
Firebase Authentication
Securely handles complex authentication flows like multi-factor authentication (MFA) and integrates seamlessly with Firestore security rules.
Primary Database
Cloud Firestore
A NoSQL document store optimized for real-time data synchronization, essential for collaborative features and live UI updates.
Binary Storage
Firebase Storage
Offers scalable object storage for raw documents (resumes, job specs) with built-in event triggers for our event-driven architecture.
Vector Database
Pinecone (Serverless)
A specialized database designed for high-performance vector search, with a usage-based pricing model that aligns with our serverless cost strategy.
Compute (Async)
Cloud Functions (2nd Gen)
Provides event-driven compute for lightweight, asynchronous triggers, such as responding to new file uploads.
Compute (Heavy)
Cloud Run
A containerized compute service ideal for long-running and resource-intensive AI orchestration and document parsing tasks.
AI Models (Cloud)
Vertex AI (Gemini 1.5 Pro)
Offers powerful multi-modal capabilities and a large context window, making it suitable for complex, multi-document analysis tasks.
AI Models (Local)
Transformers.js with WebGPU
Enables private, low-latency, and cost-effective AI inference directly in the browser, powering the platform's free tier.

This technology stack enables a powerful and scalable data flow for core platform functions.
4.2 High-Level Data Flow: Resume Ingestion
This section details the end-to-end data flow for the resume ingestion process, which showcases our event-driven architecture in action.
Upload: A user uploads a resume file via the client-side SDK. The file is sent directly to a temporary, secure bucket in Firebase Storage, which decouples the client from the application server and avoids ingress bandwidth costs and processing bottlenecks.
Trigger: The successful upload triggers an event (google.storage.object.finalize), which invokes a lightweight Cloud Function known as the "Dispatcher."
Queueing: The Dispatcher validates the file and creates a job in Google Cloud Tasks. This is a critical pattern for ensuring scalability and reliability, as it allows us to throttle the processing rate and handle retries, preventing downstream services from being overwhelmed.
Processing: The Task Queue dispatches the job to a Cloud Run service (the "Processor"). This containerized service performs the heavy lifting: it downloads the file, parses its text and structure, generates vector embeddings using Vertex AI, upserts those vectors into Pinecone, and stores the final metadata and extracted text in Firestore.
State Hydration: The frontend application listens for changes to the Firestore database using Snapshot Listeners. As soon as the Processor writes the final data, the UI updates automatically in real-time, changing the candidate's status from "Processing" to "Ready" without requiring a manual page refresh.
This flow depends on a well-defined data structure, which is outlined in the following section.
5.0 Data Modeling
5.1 Firestore Schema: Hierarchical Data
Cloud Firestore was selected for its real-time capabilities and flexible data model. To ensure performance and security in a NoSQL environment, a well-planned schema is essential. We will use a hierarchical data structure with nested subcollections to model the corporate hierarchy.
/companies/{companyId}
  /departments/{departmentId}
    /roles/{roleId}
      /applications/{applicationId}
        -> (Candidate and Analysis Data)

The rationale for using subcollections is twofold: it logically groups related data and, more importantly, it allows us to enforce strict data isolation and access control through Firestore Security Rules. This structure ensures that a user from one company can never access the data of another.
This structured data is complemented by the unstructured vector data used for semantic search.
5.2 Pinecone Vector Model
Pinecone will store the high-dimensional vector embeddings generated from the text of resumes and job descriptions. This enables powerful semantic search capabilities, allowing users to find candidates based on conceptual similarity rather than just keyword matches.
Each vector stored in Pinecone will be enriched with metadata that links it back to its corresponding document ID in Firestore (e.g., companyId, roleId, applicationId). This metadata is crucial for filtering search results, ensuring that users can only retrieve vectors associated with documents they are authorized to access.
Access to both structured and unstructured data is governed by a robust security model.
6.0 Security and Role-Based Access Control (RBAC)
6.1 Authentication and Authorization
Security is of paramount importance for a multi-tenant SaaS application that handles sensitive personal and corporate data. Our security model is built on a robust Role-Based Access Control (RBAC) mechanism enforced through Firebase Custom Claims.
When an Administrator assigns a role to a user, a Cloud Function is triggered. This function embeds the user's role, tenant ID, and specific permissions directly into their Firebase Authentication token. This token is then sent with every subsequent request to the backend.
An example of the custom claims payload is shown below:
{
  "tenant_id": "company_xyz",
  "role": "MANAGER",
  "allowed_depts": ["dept_engineering"]
}

The primary benefit of this approach is that it is both highly performant and secure. Permissions are cryptographically signed within the token and can be verified on the server for every request without requiring an additional database lookup, dramatically improving response times.
6.2 Firestore Security Rules
Firestore Security Rules provide the server-side enforcement of the access control logic defined in the custom claims. These rules are evaluated for every database request, ensuring that the permissions embedded in a user's token are respected at the database level.
The following example demonstrates how these rules enforce tenant isolation and role-based write access:
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Function to check if the user belongs to the company tenant
    function isTenant(companyId) {
      return request.auth.token.tenant_id == companyId;
    }

    match /companies/{companyId} {
      allow read: if isTenant(companyId);

      match /departments/{deptId} {
        // Users can read any department within their company
        allow read: if isTenant(companyId);
        // Write access is restricted to Admins or assigned managers
        allow write: if isTenant(companyId) &&
                     (request.auth.token.role == 'ADMIN' ||
                      deptId in request.auth.token.allowed_depts);
      }
    }
  }
}

This combination of JWT-based custom claims and declarative, server-side security rules creates a robust and scalable server-side, declarative security model for the entire platform.
7.0 Business Model and Implementation Strategy
7.1 Freemium Go-to-Market Strategy
We will adopt a freemium business model to drive product-led growth. This strategy is designed to attract a large user base by lowering the barrier to entry, allowing individuals and small teams to experience the core value of the Intelli-Hire platform without an initial financial commitment.
Our model is a Usage-Based Freemium model with two distinct tiers:
Free Tier: This tier will provide access to the platform's core features with certain usage limits (e.g., a cap on the number of resumes processed per month). To make this tier economically viable, it will run exclusively on local, in-browser AI. This leverages our local-first architecture to provide powerful functionality at a near-zero marginal cost.
Premium Tier: This tier unlocks advanced features, higher usage limits, and team collaboration tools. Crucially, premium users gain access to the powerful cloud-based AI models for more complex analysis, multi-document comparison, and external data verification, providing a clear and compelling value proposition for upgrading.
Our upgrade strategy will be contextual and value-driven. Similar to Slack's model, upgrade prompts will appear when a user attempts an action that requires a premium feature or hits a usage limit. The prompt will clearly explain the benefits of upgrading to unlock more powerful cloud-based analysis, transforming limitations into opportunities for conversion.
To measure the success of this model, we will closely track essential freemium metrics, including Free-to-Paid Conversion Rate, Free User Activation Rate, and Churn Rate.
7.2 DevOps and CI/CD Pipeline
Our DevOps strategy is centered around a Monorepo managed with tooling like Nx or Turborepo. This approach is crucial for managing shared code and ensuring type safety and consistency between the frontend and backend services.
The Monorepo project structure will be organized as follows:
apps/web: The React frontend application.
apps/functions: The Cloud Functions backend services.
libs/shared: A library of shared TypeScript interfaces (e.g., ICandidate, IAnalysisResult). This ensures that changes to backend data structures are immediately reflected in the frontend, preventing runtime errors.
A fully automated CI/CD pipeline will be implemented using GitHub Actions to ensure reliability and rapid deployment.
Validation: On every Pull Request, the pipeline will automatically run linting and unit tests on only the code affected by the change, optimizing execution time.
Preview: For each Pull Request, the web application will be automatically deployed to a Firebase Hosting Preview Channel. This provides stakeholders with a live, shareable URL for reviewing and testing new features before they are merged.
Production Deploy: Upon a merge to the main branch, the pipeline will automatically build and deploy all production services, including the Firebase Hosting web app, Cloud Functions, and Cloud Run containers.
This technical specification provides a comprehensive blueprint for building Intelli-Hire: a secure, scalable, and intelligent recruitment platform poised for significant product-led growth.

